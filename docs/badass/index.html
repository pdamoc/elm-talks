<!DOCTYPE html>
<html>
  <head>
    <title>Badass Elm</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">

      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      .small { font-size: 0.5em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
      .bg {
        width: 100wh;
        height: 100wh;
        background-image: url(buster-logo.png);
        background-repeat: no-repeat;
        background-position: left bottom; 
      }
      img {
        width: 80%;
      }
      .side-by-side img{
        width : 48%;
        display: inline-block;
      }
      .sixty img {
        width: 60%;
      }      
      .fifty img {
        width: 50%;
      }
    </style>
  </head>
  <body>
    <textarea id="source" style="display: none;">

class: center, middle, inverse, large

# Badass Elm

[A [quick](#) introduction to Elm]

???

Buna seara. Numele meu este Petre Damoc si am venit la invitatia lui Mihai ca sa va vorbesc putin despre Elm. 
Pentru cei ce nu au auzit de Elm, Elm este un limbaj functional ce compileaza la Javascript. 
Este proiectat sa genereze aplicatii web performate ce nu dau erori de executie. 

---

background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em
class: large

# Agenda

1. Why Elm?
2. Examples / Q&A

???
Prezentarea este structurata in doua parti. 
Mai intai voi vorbi cateva minute despre avantajele pe care Elm le aduce si apoi voi prezenta cateva exemple ce sper sa va faca familiari cu limbajul. 

---

background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em


layout: false
.left-column[
  ## Why Elm?
]
.right-column.large[

1. Simple vs. Easy

2. Maintainable & Reliable 

]

???
Elm este un limbaj de programare simplu ce face lucrurile complexe usoare.
Avantajele lui devin evidente cand un proiect se intinde pe mai multe luni; cand un proiect trebuie intretinut si eventual extins dupa ce a fost livrat.


---

class: center, middle
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em
 
# Simple vs. Easy
.side-by-side[
![cable good](cable_good.jpg) ![cable bad](cable_bad.jpg)
]

???
Ceva simplu este ceva usor de inteles. Ceva ce are un rol, o dimensiune sau trateaza un concept. 
In contrast, ceva usor este ceva ce este la indemana, ceva ce este familiar, deja cunoscut. 
Cele doua imagini reprezinta pentru mine contrastul dintre simplu si usor. 
Imaginea din dreapta a inceput probabil cu un singur cablu introdus in cel mai apropiat port, apoi a fost nevoie de inca un cablu si inca un cablu. 
Aceasta abordare are avantajele ei. 
Imaginea din stanga a inceput probabil cu o viziune mai clara despre ce ar fi bine sa fie la final. 
Aceasta abordare are avantajele ei. 
Elm este un limbaj declarativ a carui sintaxa este inspirata din Haskell si OCaml. 
Lucrul acesta il face sa fie nefamiliar pentru majoritatea programatorilor obisnuiti cu limbaje imperative ce au o sintaxa inspirata din C. 
Multe lucruri nu sunt usoare in Elm dar sunt simple. 
---

class: center, middle 
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em
 
# Maintainable & Reliable

"a small number of powerful concepts"

immutable data + stateless functions ➞ easy to refactor ➞ no runtime errors 

???
Simplitatea limbajului deriva dintr-un numar mic de concepte puternice. 
Toate datele din Elm sunt immutable. 
Functiile vor intoarce intotdeauna aceeasi valoare daca primesc aceleasi argumente. 
Lucrul acesta face codul sa fie foarte predictibil si in consecinta usor de schimbat. 
Fiecare schimbare este verificata de compilator. 
Daca schimbarea are efecte in alte parti ale programului, compilatorul ofera indicii legate de ce trebuie schimbat. 
Astfel sunt eliminate scaparile ce ar putea duce la erori de executie. 
 
---

class: center, middle
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em
 
# Maintainable & Reliable

 ![](noredink.png)
 .small.pull-right[\* Richard Feldman: Elm and React in production]

???
Richard Feldman, directorul de engineering de la NoRedInk (compania cea mai celebra pentru utilizarea Elm-ului) spunea in Noiembrie ca intr-un an jumate de cand folosesc Elm nu au avut nici o eroare de executie. 
Intre timp au ajuns la 80 de mii de linii de cod Elm, tot zero erori. 

---

class: center, middle, inverse, large
# Examples 

[ how to become a [badass]() at Elm ]

???
Ok, destula filozofie sa trecem la ceva mai practic. 
Pentru a deveni foarte buni la Elm este nevoie sa fie intelese acele concepte despre care vorbeam mai devreme. 

---
class: center, middle 

background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em

# Badass

.center[![badass](badass.png)]

.small.pull-right[\* from Badass by Kathy Sierra]

???
Orice concept nou invatat, orice aptitudine dobandita trece prin aceste trei etape. 
Incepe cu totul strain apoi devine cumva familiar si, daca este practicat suficient, sfarseste prin a deveni automat. 

---

class: center, middle,  
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em

# Elm = immutable data + functions

???
Programele Elm sunt formate din definitii de tipuri de date si functii care opereaza cu aceste tipuri de date. 


---
layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em


.left-column[
  ## Elm Basics: Data 
]
.right-column[

## Simple Data
```elm
name = "John Wayne"

age = 72 

weightAtBirth = 5.9

wives = ["Josephine", "Esperanza", "Pilar"]

```

## Simple Data with type annotation
```elm

name : String 
name = "John Wayne"

age : Int 
age = 72 

weightAtBirth : Float 
weightAtBirth = 5.9

wives : List String
wives = ["Josephine", "Esperanza", "Pilar"]

```

]

???
Avem tipuri de date simple: Sir de caractere, Intregi, numere reale, Liste
Valorile pot fi declarate cu sau fara declararea tipului de date. 
Daca nu este declarat tipul de date, Elm il va infera. 

---
layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em


.left-column[
  ## Elm Basics: Data 
]
.right-column[

## Records
```elm
john = 
  { name = "John Wayne"
  , age = 72 
  , weightAtBirth = 5.9
  , wives = ["Josephine", "Esperanza", "Pilar"]
  }
```

## Records with type annotation
```elm
type alias Actor = 
  { name: String
  , age: Int
  , weightAtBirth : Float
  , wives : List String
  }

john : Actor 
john = 
  { name = "John Wayne"
  , age = 72 
  , weightAtBirth = 5.9
  , wives = ["Josephine", "Esperanza", "Pilar"]
  }
```
]

???

Tipurile de date pot fi compuse in structuri mai complexe.
La fel ca toate celelate tipuri de date, aceste structuri sunt immutable. 

---
layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em


.left-column[
  ## Elm Basics: Data 
]
.right-column[

## Algebraic Data Types - ADT
```elm

type Bool = True | False 

type Maybe a = Just a | Nothing 

type Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun

type Tree a = Empty | Node a (Tree a) (Tree a)

type Role = Ceo | Manager | Drone 

type Entity = Person String Role | Machine UUID 

```
]

???

Un alt mod in care pot fi compuse tipurile de date este cu ajutorul tipurilor de date algebrice.
Acest mecanism, numit si tagged union sau union type, permite structurarea starii programului intr-un mod usor de inteles. 
Permit descompunerea starii intr-un mod mult mai precis. 

---
layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em

.left-column[
  ## Elm Basics: Functions 
]
.right-column[

## Simple Functions
```elm

add2 n = n + 2 

double n = n * 2

isNegative n = n < 0

fst (a, b) = a

fib n =
  if n < 2 then
    1
  else
    fib (n - 1) + fib (n - 2)

```

]

???
Pe langa date avem si functii. 
Acestea sunt descrise la fel cum sunt descrise si valorile cu diferenta ca parametri lor sunt pusi inainte semnului de egal. 

Functiile pot fi descrise fara descrierea tipulrilor de date pe care le primesc si le produc.
In acest caz tipurile de date sunt inferate de compilator.

---
layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em

.left-column[
  ## Elm Basics: Functions 
]
.right-column[

## Simple Functions with type annotation
```elm

add2 : number -> number
add2 n = n + 2 

double : Float -> Float
double n = n * 2

isNegative : Int -> Int 
isNegative n = n < 0

fst : (a, b) -> a
fst (a, b) = a

fib : Int -> Int 
fib n =
  if n < 2 then
    1
  else
    fib (n - 1) + fib (n - 2)

```

]

???
Sau, tipurile de date pot fi declarate explicit. 

---
layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em

.left-column[
  ## Elm Basics: Functions 
]
.right-column[

## Higher order functions
```elm

add2 n = n + 2 

double n = n * 2

addAndMultiply add multiply n =
  multiply (add n)

result = 
  addAndMultiply add2 double 2

```


## Function composition
```elm

(>>) : (a -> b) -> (b -> c) -> (a -> c)
(>>) f g x =
  g (f x)

squreIsNotEven = 
  sqrt >> isEven >> not

```
]

???
Functiile pot avea parametri alte functii. 
Lucrul acesta face posibla compunere usoara de functii. 



---
layout: false
.left-column[
  ## Elm Basics: Functions 
]
.right-column[

## Function application
```elm

(|>) : a -> (a -> b) -> b
(|>) x f =
  f x

blueNgon =
  scale 2 (move (10,10) (filled blue (ngon 5 30)))

blueNgon = 
  ngon 5 30
    |> filled blue
    |> move (10,10)
    |> scale 2

```
]

???
Exista inclusiv o functie care primeste o valoare si o alta functie si aplica functia primita asupra acelei valori. 
Lucrul acesta permite structurarea unei transformari complexe intr-un mod mult mai usor de inteles. 
Puteti vedea aici si mecanismul de currying. 
O functie ce primeste doua argumente este transformata intr-o functie ce primeste un singur argument prin aplicare partiala. 


---
layout: false
.left-column[
  ## Elm Basics: Functions 
]
.right-column[

## Pattern Matching 
```elm

type alias Model = Int

type Msg  = Increment | Decrement | Add Int 

update : Msg -> Model -> Model
update msg model =
  case msg of
    Increment ->
      model + 1
    
    Decrement ->
      model - 1

    Add i ->
      model + i

```
]

???
In oglinda cu tipurile de date avem si pattern matching-ul 
Lucrul acesta este facut cu o expresie de tip "case".
Compilatorul va verifica structura tipului de date si va atentiona daca anumite cazuri nu sunt tratate. 

---

class: center, middle
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em
 
# The Elm Architecture

Level 1: Functions 

.large.remark-code[data ➞ function ➞ DOM]

???
Sa trecem acum la structura unui program Elm. 
Cel mai simplu program este o functie ce produce un element Html

---
layout: false
.left-column[
  ## Level 1: Functions 
]
.right-column[

```elm
import Html exposing (text)

main =
  text "Hello, World!"
```

```elm
import Html exposing (Html, text)

greet: String -> Html msg
greet name =
  text ("Hello, " ++ name ++ "!")

target : String 
target = "World"

main : Html msg
main =
  greet target
  
```
]

???
In cazul de fata, `text` produce un element html de tip textNode. 
In partea de jos text este folosit in cadrul unei functii de intampinare. 

---

class: center, middle
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em
 
# The Elm Architecture

Level 2: Simple State Transformations 

.sixty[![](TEALevel2.png)]

???
Cum generarea de html static nu-i chiar atat de interesanta sa trecem la structura unui program dinamic. 
Aici avem de a face cu Arhitectura Elm. 
Arhitectura Elm este o arhitectura unidirectionala. 
Se pleaca de la un model sau o stare a programului. 
Starea programului este afisata. 
Interfata afisata produce evenimente ce cu ajutorul functiei update genereaza noua stare a programului si ciclul este reluat. 

---

layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em

.left-column[
  ## Level 2: Simple State 
]
.right-column[

```elm
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

main = 
  Html.beginnerProgram 
    { model = model, view = view, update = update }

-- MODEL
type alias Model = Int

model : Model
model =  0

-- UPDATE
type Msg  = Increment | Decrement

update : Msg -> Model -> Model
update msg model =
  case msg of
    Increment ->
      model + 1
    Decrement ->
      model - 1

-- VIEW
view : Model -> Html Msg
view model =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (toString model) ]
    , button [ onClick Increment ] [ text "+" ]
    ]
```
]

???
Aici avem implementarea unui contor. 
Modelul este de fapt un numar intreg. 
apoi definim tipul de mesaj ce va circula in program. 
Avem incrementare si decrementare
functia de update trateaza fiecare dintre cele doua mesaje producand urmatoarea stare a sistemului.
functia de vizualizare afiseaza valoarea modelului incadrata de doua butoate. 
Unul genereaza mesaje de decrementare, celalalt mesaje de incrementare. 
Atat. 

Toate programele ce nu necesita informatie externa pastreaza aceasta arhitectura simpla. 
Numaraul mesajelor poate ajunge sa fie foarte ridicat. 
Functia de vizualizare poate fi compusa din mai multe functii ce sunt apelate pe componente ale modelului dar structura de ansamblu ramane aceeasi. 

---

class: center, middle
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em
 
# The Elm Architecture

Level 3: Side-Effects 

.fifty[![](TEALevel3.png)]

???
In cazul in care este nevoie de informatie externa, fie ca-i vorba de un numar aleator sau ca-i vorba de informatie de pe un alt server, arhitectura este extinsa pentru a gestiona in plus comenzi si abonamente. 
O comanda este o cerinta pe care programul Elm o face catre runtime. 
In urma acestei cerinte programul va primi un mesaj ce va incapsula rezultatul cerintei. 
La inializare, pe langa stare programul primeste si comenzile initiale. 
La fiecare mesaj primit, functia update poate intoarce si o serie de comenzi. 
Componenta de subscriptions permite abonarea la o serie de mesaje ce sunt generate automat. 
Un exemplu ar fi un generator ce la fiecare secunda genereaza un mesaj. 

Cats example 

---

layout: false
background-image: url(elm_logo.svg)
background-position: left 1em bottom 1em

.left-column[
  ## Interop 
]
.right-column[

## Integrating Elm into your app

```html
<div id="elm"></div>

<script src="elm.js"></script>

<script>
    var node = document.getElementById('elm');
    var app = Elm.Main.embed(node);
</script>
```
]

???
Varianta ideala de experimenta cu Elm este sa adaugati putin Elm intr-un program deja existent. 
Sa-i dati unui mic program Elm ceva de facut. 
Acesta este modul in care elm poate fi inclus intr-un proiect mai mare. 


---
class: center, middle, inverse, large

# Thank you! 


    </textarea>

    <script src="remark-latest.min.js"></script>
    <script>
      var hljs = remark.highlighter.engine;
    </script>
    <script src="remark.language.js"></script>
    <script>
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark',
          highlightLines: true
        }) ;
    </script>
  </body>
</html>
